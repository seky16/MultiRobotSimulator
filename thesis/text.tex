
%\begin{enumerate}[label=\alph*)]
%\end{enumerate}

%\begin{definice}
%\end{definice}

%\sloppy

%\begin{poznamka}
%\end{poznamka}

%\begin{subequations}
%	\begin{align}
%	\end{align}
%\end{subequations}

%\begin{priklad}
%\end{priklad}

%\begin{veta}
%\end{veta}

%\begin{proof}
%\end{proof}

%\begin{figure}[!h]
%	\begin{center}
%		\includegraphics*[scale=0.9]{obr/krivka2}
%	\end{center}
%	\caption[caption]{\centering B-spline křivka stupně 2 (modře) a její řídící polygon (černě)\linebreak pro $U=\left\lbrace 0,0,0,1/4,1/2,3/4,3/4,1,1,1\right\rbrace $}
%	\label{obrKrivka}
%\end{figure}

%\begin{algorithm}[H]
%	\caption{Generování uzlového vektoru}
%	\label{GenKnotVec}
%	\begin{algorithmic}[1]
%		\Function{GenerateKnotVector}{$n,p$}
%		\State $j=1$;
%		\For{$i=0,\dots,n+p+2$}
%		\If{$(i\leq p)$}
%		\State $\text{knotVector}\left[i\right]=0$;
%		\ElsIf{$(i\leq n)$}
%		\State $\text{knotVector}\left[i\right]=j/\left(n-p+1\right)$;
%		\State $j\text{++}$;
%		\Else
%		\State $\text{knotVector}\left[i\right]=1$;
%		\EndIf
%		\EndFor
%		\State \textbf{return} knotVector;
%		\EndFunction
%	\end{algorithmic}
%\end{algorithm}

%\begin{subequations}
%	\begin{gather}
%	\end{gather}
%\end{subequations}

%\begin{equation}
%s=
%\begin{cases}
%\end{cases}
%\end{equation}

\chapter{Plánování cesty}
Nutnou podmínkou pro fungování autonomního robota je jeho navigace, která se skládá ze tří procesů:
\begin{enumerate}
	\item Lokalizace -- schopnost robota určit svoji polohu a orientaci v prostředí. Odpovídá na otázku "Kde se nacházím?"
	\item Mapování -- uložení dat získaných ze senzorů robota při prozkoumávání prostředí do dané reprezentace. Dává odpověď na otázku "Jak vypadá okolní svět?".
	\item Plánování cesty -- Proces nalezení posloupnosti akcí, které vedou k dosažení daného cíle. Jedná se o otázku "Jak se dostanu do cílové pozice?".
\end{enumerate}
Lokalizace a mapování jsou navzájem provázané -- při lokalizaci robota v prostředí je nutné znát jeho reprezentaci a pro správné mapování je nutné znát současnou polohu, ze které byly daná data získána. Plánování cesty je s těmito procesy úzce spjato, jelikož hledáme cestu v závislosti na současné poloze a reprezentaci prostředí. [Meyer, Cyrill, Introduction]

\section{Formulace problému plánování cesty}
\subsection{Stavový prostor}
Každou jedinečnou situaci, do které se robot v prostředí může dostat, nazveme \emph{stav} $x$. Je důležité aby stav obsahoval právě ty informace, které potřebujeme k vyřešení problému. Množina stavů (označovaných $x$) se nazývá \emph{stavový prostor} $X$. Aplikací \emph{akce} $u$ na daný stav $x$ přejdeme do stavu $x'$, což je dáno tzv. \emph{přechodovou funkcí} $f$,
\begin{equation}
x'=f\left(x,u\right).
\end{equation}
Množinu $U(x)$, která reprezentuje všechny možné akce proveditelné ve stavu $x$ nazveme \emph{akčním prostorem}. Můžeme také definovat množinu všech možných akcí ve všech stavech jako
\begin{equation}
U=\bigcup_{x \in X} U(x).
\end{equation}
Dále definujeme množinu \emph{cílových stavů} $x_G \subset X$. Cílem obecného problému plánování je nalézt konečnou posloupnost akcí, která převede počáteční stav $x_0$ na některý z cílových stavů z $X_G$. 

Tento problém je možné interpretovat jako \emph{stavový přechodový graf}, ve kterém vrcholy reprezentují stavový prostor $X$ a orientovaná hrana grafu ze stavu $x$ do stavu $x'$ reprezentuje akci $u$ splňující funkci $x'=f(x,u)$. [LaValle]

\subsection{Pracovní prostor}
Prostředí, ve kterém se robot pohybuje nazveme \emph{pracovní prostor} $W$. Jedná se o $N$-rozměrný Euklidovský prostor ($\mathbb{R}^2$ nebo $\mathbb{R}^3$). V pracovním prostoru se mohou vyskytovat různé překážky, ty značíme $O\subset W$. Překážky mohou být buď statické (nemění svoji polohu) nebo dynamické. [Introduction]


\subsection{Konfigurační prostor}
Plánování cesty přímo v pracovním prostoru je z hlediska časové náročnosti velice neefektivní, jelikož stavový prostor je široký. Přináší také veliké problémy při zohlednění stupňů volnosti, různých tvarů a dalších mechanických omezení robota, které jsou pro různé aplikace odlišné. Pro zobecnění se používá tzv. \emph{konfigurační prostor} $C$.

V konfiguračním prostoru je robot reprezentován jako bod. \emph{Konfigurací} $q$ se myslí kompletní popis polohy a natočení robota v pracovním prostoru $W$. Konfigurační prostor $C$ je tedy množinou všech konfigurací $q$. Překážky $O$ vymezují \emph{kolizní konfigurační prostor} $C_obs$ tj. ty konfigurace, ve kterých by byl robot v kolizi s překážkou. Tzv. \emph{volný konfigurační prostor} je potom množinou všech přípustných konfigurací $C_{free}=C \setminus C_{obs}$. Nalezení \emph{přípustné cesty} je potom zobrazení
\begin{equation}
p: \left[0;L\right]\to C_{free},
\end{equation}
kde $L$ je délka cesty $p$. [Introduction,10.1.1.160.1972]

\subsection{Plánování cesty}

Problém plánování cesty lze tedy pomocí konfiguračního prostoru transformovat na problém hledání cesty ve stavovém přechodovém grafu. Uzly grafu jsou přípustné konfigurace $c\in C_{free}$. Každá hrana (tj. akce, přechod mezi danými konfiguracemi) má danou cenu. [hsplanguide]

Je důležité brát v potaz účel daného robota, jelikož různé aplikace mohou mít různé požadavky. Ve většině případů se jedná o optimalizaci uražené vzdálenosti (tj. hledání nejkratší cesty). Dále je nutné dbát na účinnost, přesnost a bezpečnost robota i ostatních členů prostředí. Hledáme tedy ideálně cestu, při které se vyhneme kolizi s překážkami a dostaneme se do cíle v co nejkratším čase a za použití co nejméně energie. [Introduction]

%Cílem plánování cesty je nalézt cestu z dané startovací pozice do cíle a při tom se vyhnout kolizi s překážkami. Zároveň je cílem optimalizovat nějakou kriteriální funkci, většinou uraženou vzdálenost, čas strávený cestou nebo co nejnižší energetický výdaj. [07342773;05585236;Liang15] 


\section{Plánování cesty pro více robotů}
Výše byl definovaný problém plánování cesty robota, ze kterého vycházíme při definici problému plánování cesty pro více robotů. Obecně se jedná o situaci, kdy máme $m$ robotů v $k$-rozměrném pracovním prostoru a každý robot má danou startovní a cílovou konfiguraci, tj. pozici a orientaci. Je požadováno nalezení cesty pro každého robota, při které se budou roboti vyhýbat překážkám i sobě navzájem. [ACooperativePath...]

Případy využití několika robotů současně jsou stále častější. Jedná se jak o použití v přepravě, průmyslu, zemědělství, rybaření, těžbě např. dřeva, hledání ztracených osob, prohledávání neznámých planet nebo likvidace toxického odpadu, tak o vojenské využití -- řízení bezpilotních letounů, pokládání nebo zneškodnění min, atd. [dudek1996]

Využití několika robotů může mít oproti použití pouze jednoho robota několik potenciálních výhod:
\begin{itemize}
	\item Prostorové rozložení -- vykonání úkonů v rozlehlých pracovních prostorech, které přesahují možnosti jednoho robota. Např. odpálení rakety otočením dvou klíčů současně.
	\item Celkový výkon systému -- systém několika robotů může lépe optimalizovat cenovou funkci jako např. čas potřebný k vykonání úkolu nebo celková energie spotřebovaná roboty.
	\item Sdílení informací -- např. více robotů je lépe schopno se lokalizovat navzájem, pokud si vyměňují informace.
	\item Cena -- použití několika jednoduchých (levnějších) robotů, kteří jsou lehčí naprogramovat, může být levnější než použití jednoho komplexního (drahého) robota.
	\item Spolehlivost, flexibilita -- při selhání jednoho robota jej může nahradit další.
\end{itemize}
[57313;dudek1996]


Plánování cesty pro více robotů lze rozdělit do několika skupin podle různých kriterií:
\begin{enumerate}
	\item Podle úplnosti
	\begin{enumerate}
		\item \emph{Úplné} -- vždy naleznou cestu (pokud existuje) nebo ověří, že neexistuje. Časová náročnost těchto algoritmů však roste exponenciálně s počtem robotů.
		\item \emph{Heuristické} -- nemusí nalézt žádnou cestu, i když existuje.
	\end{enumerate}
	\item Podle typů jednotlivých robotů
	\begin{enumerate}
		\item \emph{Homogenní} -- schopnosti robotů jsou identické.
		\item \emph{Heterogenní} -- schopnosti robotů jsou různé. Každý robot má vlastní specializaci pro daný úkol. Obecně se jedná o náročnější plánování.
	\end{enumerate}
	\item Podle vzájemného chování robotů
	\begin{enumerate}
		\item \emph{Kooperativní} -- každý robot zná plány všech ostatních robotů. Roboti pracují společně na společném cíli. Speciálním případem je skupina mobilních robotů, která musí zachovávat předem určenou formaci, např. sekání fotbalového hřiště nebo přenášení nějakého předmětu více roboty.
		\item \emph{Nekooperativní} -- roboti neznají plány ostatních robotů a musí tak předvídat jejich pohyby.
		\item \emph{Antagonistické} -- každý robot se snaží dosáhnou svého cíle a případně zamezit ostatním robotům v dosažení jejich cílů.
	\end{enumerate}
	\item Podle povahy prostředí
	\begin{enumerate}
		\item \emph{Statické} -- obsahuje pouze překážky, které nemění svoji polohu.
		\item \emph{Dynamické} -- obsahuje pohybující se překážky (např. lidé).
	\end{enumerate}
	\item Podle znalosti prostředí
	\begin{enumerate}
		\item \emph{Globální plánování cesty} -- roboti mají úplnou znalost pracovního prostoru před plánováním cesty.
		\item \emph{Lokální plánování cesty} -- roboti mají neúplnou nebo žádnou znalost okolního prostředí. Musejí tedy v reálném čase snímat pomocí senzorů polohu překážek, vytvářet mapu prostředí a hledat v ní cestu.
	\end{enumerate}
	\item Podle ??
	\begin{enumerate}
		\item \emph{Offline} -- nejdříve je provedeno plánování cesty pro všechny roboty, poté se roboti podle těchto plánů začnou pohybovat.
		\item \emph{Online}, příp. \emph{real-time} -- plánování cesty je spojeno s pohybem robotů. Nalezená cesta nemusí být optimální nebo vůbec nalezena, roboti ale netráví dlouhý čas plánováním a dokáží rychle reagovat i na změny prostředí.
	\end{enumerate}
	\item Podle přístupu k řešení problému
	\begin{enumerate}
		\item \emph{Centralizované} -- bere v úvahu všechny roboty zároveň jako jeden propojený systém. Snaží se o optimalitu a úplnost, proto v praxi trpí velikou časovou náročností.
		\item \emph{Distribuované} -- rozdělí plánování na menší nezávislé nebo slabě závislé problémy, které řeší každý robot zvlášť. Schopné rychle nalézt dobré řešení, avšak ztrácí na úplnosti.
	\end{enumerate}
\end{enumerate}
[06729271;Silver05;1305.2889;Introduction;ACooperativePath...;Asma17]

\section{Zpracování prostředí}
%Pro zobecnění problému plánování cesty robota do prohledávání v konfiguračním prostoru $C$ je nutná vhodná reprezentace prostředí, ve kterém se robot pohybuje.
\subsection{Rozklad do buněk (Cell decomposition)}
\subsection{Mapy cest (Roadmaps)}
Visibility graph, Voronoi diagram
\subsection{Potenciálová pole (Potential fields)}

\chapter{Metody}
\section{Klasické metody}
\subsection{A*}
\subsection{Local Repair A*}
Zatímco použití běžného A* algoritmu je při hledání cesty pro jednoho robota plně dostačující, při pohybu více robotů ve stejný čas může tento přístup lehce selhat a dojít ke srážce mezi roboty. Běžný postup, používaný například i ve videohrách, je využití takzvaného \emph{Local Repair A*} (LRA*) algoritmu.

Local Repair A* nejprve vyhledá pro každého robota nejkratší cestu pomocí klasického A* algoritmu (viz výše), nezávisle na ostatních. Bere v potaz pouze sousedy, kteří jsou v sousedních buňkách startovací pozice. Po vyhledání jednotlivých cest se po nich roboti začnou pohybovat. Při pohybu vždy robot kontroluje následující pozici, do které se má přesunout, a pokud by hrozila kolize, protože je na této pozici již jiný robot, označí tuto pozici jako překážku a přepočítá zbytek cesty do cíle s touto novou informací.

% TODO obrázek ?

Je možné (a velice časté), že dojde k zacyklení jednoho nebo více robotů. Jedno z řešení tohoto problému, je při každém přeplánování trasy zvýšit tzv. \emph{úroveň agitace}. Při hledání je potom přidán náhodný šum úměrný úrovni agitace k hodnotě heuristické funkce $h$. Zvýšením náhodnosti chování robotů při plánování nové cesty se předpokládá, že uniknou z problematického místa, protože si vyberou jinou cestu.

Algoritmus Local Repair A* má několik nevýhod. Obzvláště v úzkých koridorech je velká pravděpodobnost ke vzniku zácpy, která může trvat dlouhou dobu, případně se ji nepodaří vyřešit vůbec. Roboti v zácpě neustále znovu plánují svoje cesty a tím dochází k opakovanému spouštění celého A* algoritmu. Toto vede k nepříznivému, \uv{neinteligentnímu} chování, případně k úplnému selhání hledání cesty.

% TODO pseudokód? 

\subsection{Cooperative A*}\label{sec:Coop}
\emph{Cooperative A*} se snaží vyřešit problém LRA*, kdy roboti navzájem neznají plány ostatních. Je tedy potřebné, mít znalost nejen o statických překážkách, ale i o pohybu všech robotů. Jelikož není žádná možnost, jak do statické (2D) mapy zaznamenat dynamický pohyb robotů, je potřeba mapu rozšířit o další dimenzi -- čas. Při pohybu mřížkou se tedy nemění pouze souřadnice polohy, např. $\left(x,y\right)\to\left(x,y+1\right)$, ale i časová souřadnice $\left(x,y,t\right)\to\left(x,y+1,t+1\right)$. V některých situacích, například při zácpě před úzkým koridorem, je výhodné nedělat nic a počkat, než se prostor vyčistí. Je tedy vhodné zavést jednu další akci \emph{čekat (wait)}, kdy přecházíme ze stavu $\left(x,y,t\right)$ do stavu $\left(x,y,t+1\right)$.

Hledání cesty tedy provádíme na této 3D mřížce, kde cena přechodu mezi stavy je rovna době, kterou zabere přechod mezi nimi, tedy jedna. Přechod je přípustný, pokud v cílové buňce není překážka nebo jiný robot.
%(bude vysvětleno později -- viz \hyperref[sec:reservationTable]{rezervační tabulka})
A* algoritmus nalezne cestu s nejnižší cenovou funkcí, tj. nejrychlejší cestu do cíle. Tato cena může být vyšší než samotná délka cesty, kvůli již zmíněné akci \emph{čekat}. 

\subsubsection{Rezervační tabulka}\label{sec:reservationTable}

Pro zohlednění pohybu robotů se využívá tzv. \emph{rezervační tabulka}. Po té, co každý robot naplánuje svoji cestu, je každý stav této cesty zaznamenán do rezervační tabulky. Každý stav zanesený do této tabulky je při plánování dalšími roboty považován za překážku v na dané pozici v daném čase. 

% TODO předělat obrázek
\begin{figure}[!h]
	\begin{center}
		\includegraphics*[scale=0.5]{obr/reservationTable}
	\end{center}
	\caption[caption]{Rezervační tabulka [coop-path-AIWisdom]}
	\label{obr:reservationTable}
\end{figure}

Na obrázku \ref{obr:reservationTable} můžeme vidět, jak Cooperative A* funguje. První robot (vlevo), nalezne cestu do svého cíle a jednotlivé stavy zaznamená do rezervační tabulky. Druhý robot při svém plánování považuje tyto stavy za překážky, tím se vyhne kolizi s prvním robotem a úspěšně nalezne cestu do cíle. Tuto cestu poté také zaznamená do rezervační tabulky.

Rezervační tabulka bohužel nezohledňuje situaci, kdy roboti jedou přímo naproti sobě. Pokud například první robot zarezervuje stavy $\left(x,y,t\right)$ a $\left(x+1,y,t+1\right)$, druhému robotovi nic nebrání v tom zarezervovat stavy $\left(x+1,y,t\right)$ a $\left(x,y,t+1\right)$. Řešením je buď zaznačit do rezervační tabulky jak cílový, tak výchozí stav akce, případně explicitně kontrolovat přímé kolize.

% TODO přesunout do implementace?
Jednou z nevýhod Cooperative A* algoritmu, je již zmíněná přidaná dimenze navíc, která značně zvyšuje výpočetní náročnost algoritmu. Rezervační tabulka, je naštěstí z podstaty řídká, jelikož počet rezervací v daném časovém okamžiku je přímo úměrný počtu robotů. Tabulku lze tedy efektivně implementovat jako hašovací tabulku, kde klíčem je daný stav $\left(x,y,t\right)$.

Další z nevýhod je, že Cooperative A* (stejně jako žádný jiný distribuovaný hladový algoritmus) nedokáže vyřešit určité typy problémů, kdy řešení jednoho robota zamezí v možnosti dalšího robota nalézt přípustnou cestu. Jeden příklad tohoto problému můžeme vidět na obrázku \ref{obr:unsolvableCoopProblem}. První robot při naplánování cesty z výchozí pozice $S_1$ do cíle $G_1$ zamezí v cestě druhému robotu, který se snaží naplánovat cestu z pozice $S_2$ do cíle $G_2$.

% TODO předělat obrázek
\begin{figure}[!h]
	\begin{center}
		\includegraphics*[scale=0.5]{obr/unsolvableCoopProblem}
	\end{center}
	\caption[caption]{Příklad problému, který nelze vyřešit pomocí Cooperative A* [Silver05]}
	\label{obr:unsolvableCoopProblem}
\end{figure}

Pro Cooperative A* lze použít libovolnou přípustnou heuristickou funkci. Při využití mřížkových map se nejčastěji používá Manhattanská metrika. Při použití na složitých mapách, kde dochází k plánování cyklických cest, je ovšem tato metrika nedostatečná.

% TODO předělat obrázek, rozdělit do dvou?
\begin{figure}[!h]
	\begin{center}
		\includegraphics*[scale=0.5]{obr/coopManh}
	\end{center}
	\caption[caption]{Použití Manhattanské metriky v Cooperative A* [coop-path-AIWisdom]}
	\label{obr:coopManh}
\end{figure}

Na obrázku \ref{obr:coopManh} vlevo vidíme hodnoty $f$ buněk, které při plánování prohledá A* algoritmus. Vidíme, že algoritmus prohledal skoro všechny buňky, i ty co reálně nevedou k cíli. Při použití Cooperative A*, tedy plánování v prostoru rozšířeném o jednu dimenzi, vidíme na obrázku \ref{obr:coopManh} vpravo, že tento algoritmus prohledává dané buňky několikrát, vždy v různých časech. Algoritmus se snaží vrátit zpět a prohledat buňky s lepší hodnotou $f$ v dalších časech a tím se několikanásobně zhoršuje časová náročnost tohoto algoritmu.

\subsection{Hierarchical Cooperative A*}
%Heuristickou funkci lze zlepšit pomocí abstrakce stavového prostoru. Jelikož je díky přítomnosti více robotů prostředí dynamické, je nutné použít \emph{Hierarchical A*}, který počítá abstraktní vzdálenosti na požádání.

%\emph{Hierarchical Cooperative A*} využívá jednoduchou abstrakci, kterou je 

Heuristickou funkci lze zlepšit pomocí abstrakce stavového prostoru.  Jako odhad vzdálenosti z dané buňky do cíle použijeme nejkratší možnou vzdálenost bez závislosti na čase a ostatních robotech. Jedná se tedy o délku cesty nalezenou A* algoritmem na 2D mřížce. Tuto vzdálenost nazveme \emph{pravá vzdálenost}.

% TODO předělat obrázek
\begin{figure}[!h]
	\begin{center}
		\includegraphics*[scale=0.5]{obr/hierarchCoopMetric}
	\end{center}
	\caption[caption]{Použití pravé vzdálenosti [coop-path-AIWisdom]}
	\label{obr:hierarchCoopMetric}
\end{figure}

Na obrázku \ref{obr:hierarchCoopMetric} vidíme, že při použití pravé vzdálenosti je počet prohledaných buněk minimální a robot postupuje přesně podél nejkratší cesty až do cíle. Pouze pokud při cestě narazí na další roboty, prohledá buňky navíc. Čas prohledávání je tedy přímo úměrný potřebné úrovni kooperace mezi roboty.

Pravou vzdálenost je potřebné spočítat pro každou buňku, kterou Cooperative A* prohledá. Pokud bychom pokaždé hledali cestu z dané buňky do cíle pomocí klasického A* algoritmu, bylo by celkové plánování cesty ještě pomalejší, než použití horší heuristické funkce. Jednou z možností je spočítat všechny abstraktní vzdálenosti dopředu, ale z důvodu, že se jedná o dynamický problém a tyto vzdálenosti bychom museli počítat pro každého robota, není toto řešení adekvátní. Další možností je využití \emph{Hierarchical A*}, který počítá abstraktní vzdálenosti na požádání.

\subsubsection{Reverse Resumable A*}
Jednou z vlastností A* algoritmu je, že pokud využíváme konzistentní heuristickou funkci, tak při prohledávání dané buňky (při vložení do seznamu \emph{closed}) známe nejkratší cestu z výchozí pozice do této buňky $g$.

Této vlastnosti můžeme využít a hledat cestu "pozpátku". Začneme-li v cílové pozici, tak po dokončení prohledávání (jakmile dojdeme do počáteční pozice) vidíme (jak ukazuje obrázek \ref{obr:backwardsSearch}), že hodnoty $g$ pro každou prohledanou buňku obsahují reálnou nejkratší vzdálenost do cíle.

\begin{figure}[!h]
	\begin{center}
		\includegraphics*[scale=0.5]{obr/backwardsSearch}
	\end{center}
	\caption[caption]{Příklad zpětného prohledávání [coop-path-AIWisdom]}
	\label{obr:backwardsSearch}
\end{figure}

Po nalezení cesty pomocí zpětného prohledávání nemusíme mít expandované všechny potřebné buňky a tedy jejich $g$ hodnoty. Naštěstí můžeme v prohledávání znovu pokračovat, dokud nenarazíme na danou buňku. Tento postup nazveme \emph{Reverse Resumable A*}, jehož pseudokód je popsán v algoritmu \ref{alg:RRA}.
\\
\\
Cooperative A*, který jako heuristickou funkci používá pravou vzdálenost nazveme \emph{Hierarchical Cooperative A*}. Plánování cesty tedy probíhá tak, jak je popsáno v podkapitole \ref{sec:Coop}. Pro odhad vzdálenosti voláme metodu \texttt{AbstractDict}, která ověří, jestli je daná buňka expandovaná. Pokud ano, vrátíme její $g$ hodnotu. Pokud není, pokračujeme v hledání pomocí Reverse Resumable A* algoritmu, dokud neexpandujeme požadovanou buňku a nezískáme tak její $g$ hodnotu.

\begin{algorithm}[H]
	\caption{Reverse Resumable A*}
	\label{alg:RRA}
	\begin{algorithmic}[1]
		\Function{InitialiseRRA*}{$S,G$}
			\State $G.g\gets 0$
			\State $G.h\gets$ \Call{Heuristic}{$G,O$}
			\State $Open\gets\left\{ G \right\}$
			\State $Closed\gets\emptyset$
			\State \Call{ResumeRRA*}{$O$}
		\EndFunction
		\Statex
		\Function{ResumeRRA*}{$N$}
			\While{$Open\neq\emptyset$}
				\State $P\gets Open.pop()$
				\State $Closed.add(P)$
				\If{$P=N$}
					\State \textbf{return} success
				\EndIf
				\ForAll{$Q\in$ \Call{Neighbors}{$P$}.$reverse()$}
					\State $tempG\gets P.g+$ \Call{Cost}{P,Q}
					\State $tempH\gets$ \Call{Heuristic}{$G,O$}
					\If{$Q\notin Open$ \textbf{and} $Q\notin Closed$}
						\State $Open.add(Q)$ with $f=\infty$
					\EndIf
					\If{$Q\in Open$ \textbf{and} $(tempG+tempH)<Q.f$}
						\State $Q.g=tempG$
						\State $Q.h=tempH$
					\EndIf
				\EndFor
			\EndWhile
			\State \textbf{return} failure
		\EndFunction
		\Statex
		\Function{AbstractDist}{$N$}
			\If{$N\in Closed$}
				\State \textbf{return} $N.g$
			\EndIf
			\If{\Call{ResumeRRA*}{$N$} = success}
				\State \textbf{return} $N.g$
			\EndIf
			\State \textbf{return} $+\infty$
		\EndFunction
	\end{algorithmic}
\end{algorithm}
 
\section{Heuristické metody}
Probabilistic Roadmaps, Rapidly-exploring Random Trees, Neural Networks, Genetic Algs, Simulated Annealing, ACO, PSO, Fuzzy

\chapter{Implementace vybraných algoritmů}
\section{Aplikace}
\subsection{GUI}
\subsection{Plug-in systém}
\subsection{MovingAI benchmarks}
\subsection{Implementované algoritmy}
LRA*, CA*, HCA*

\chapter{Vyhodnocení výsledků}

\clearpage
